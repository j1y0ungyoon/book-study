# chapter 1. 디자인 패턴과 프로그래밍 패러다임

## section 1. 디자인 패턴

### 1.1 디자인 패턴

디자인 패턴이란, 프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 해결할 수 있도록 하나의 "규약" 형태로 만들어 놓은 것을 의미한다.

#### 1.1.1 싱글톤 패턴

싱글톤 패턴(singleton pattern)은 하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴이다. 하나의 클래스를 기반으로 단 하나의 인스턴스를 만들어 이를 기반으로 로직을 만드는데 쓰인다.

- 보통 데이터베이스 연결 모듈에 많이 사용한다.
- 장점: 인스턴스를 생성할 때 드는 비용이 줄어든다
- 단점: 의존성이 높아진다.

자바에서의 싱글톤 패턴 은 중첩 클래스를 이용하는 방법이 가장 대중적이다.

**싱글톤 패턴의 단점**
싱글톤 패턴은 TDD(Test Driven Development)를 할 때 걸림돌이 된다.
TDD를 할 때 단위 테스트(서로가 독립적이어야 하며 테스트를 어떤 순서로든 실행할 수 있어야함)를 주로 한다.
싱글톤 패턴은 미리 생성된 하나의 인스턴스를 기반으로 구현하는 패턴이므로 각 테스트마다 **독릭적인** 인스턴스를 만들기가 어렵다.

**의존성 주입**
싱글톤 패턴은 사용하기가 쉽지만, 모듈 간의 결합을 강하게 만드는 단점이 있어 의존성 주입(DI, Dependency Injection)을 통해 결합을 느슨하게 만들어 해결한다. 의존성 주입은 중간에 의존성 주입자(dependency injection)가 가로채 메인 모듈이 간접적으로 의존성을 주입하는 방식이다.

- 의존성은 종속성이라고도 한다. (eg. A가 B에 의존성이 있다는 것은 B의 변경 사항에 대해 A또한 변해야한다는 것)
- 디커플링 된다. (메인 모듈은 하위 모듈에 대한 의존성이 떨어지게 되는 것)

**의존성 주입의 장점**

- 모듈들을 쉽게 교체할 수 있는 구조가 되어 테스팅 하기도 쉽고 마이그레이션을 하기도 수월하다.
- 애플리케이션 의존성 방향이 일관된다.
- 애플레케이션을 쉽게 추론할 수 있다.
- 모듈 간의 관계들이 명확해진다.

**의존성 주입의 단점**

- 모듈이 불리가 되므로 클래스 수가 늘어나 복접성이 증가된다.
- 약간의 타임 패널티가 생기기도한다.

**의존성 주입 원칙**

- 상위 모듈은 하위 모듈에서 어떠한 것도 가져오지 않아야한다.
- 추상화에 의존해야한다.
- 추상화는 세부 사항에 의존하지 말아야한다.

#### 1.1.2 팩토리 패턴

팩토리 패턴(factory pattern)은 객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 채턴이다. 상속관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정하고, 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정하는 패턴이다.

- 느슨한 결합을 가진다.
  - 상위 클래스와 하위 클래스가 분리되기 때문.
- 유연성을 갖게된다.
  - 상위 클래스에서는 인스턴스 생성 방식에 대해 알 필요가 없기 때문
- 유지 보수성이 증가된다.
  - 객체 생성 로직이 따로 떼져있기 때문에 코드를 리팰터링 하더라도 한 곳만 고칠수 있다.

**ENUM**

- enum은 상수의 집합을 정의할 때 사용되는 타입이다. enu을 기반으로 상수 집합을 관리하면 코드를 리팩터링할 때 상수 집합에 대한 로직 수정 시 이 부분만 수정하면 된다는 장점이 있고, 본질적으로 스레드세이프(thread safe)하기 때문에 싱글톤 패턴을 만들 때 도움이 된다.

#### 1.1.3 전략 패턴

전략 패턴(strategy pattern)은 정책 패턴(policy pattern)이라고도 한다.
객체의 행위를 바꾸고 싶은 경우 '직접' 수정하지 않고 전략이라고 부리는 '캡슐화한 알고리즘'을 컨텍스트 안에서 바꿔주면 상호 교체가 가능하게 만드는 패턴이다. (e.g 무언가 결제할 때 카카오페이, 네이버페이 또는 다양한 방법으로 결제)

**passport의 전략 패턴**
passport는 node.js 인증 모듈을 구현할 때 쓰는 미들웨어 라이브러리로, 여러 가지 전략을 기반으로 인증할 수 있게 하는 전략 패턴을 활용한 라이브러리이다.

#### 1.1.4 옵저버 패턴

옵저버 패턴(observer patter)은 주체가 어떤 객체(subject)의 상태 변화를 관찰하다가 상태 변화가 있을 대마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 디자인 패턴이다. (e.g 트위터)

- 주체란 객체의 상태 변화를 보고 있는 관찰자이다.
- 관찰자, 옵저버들이란 이 객체의 상태 변화에 따라 전달되는 메스드 등을 기반으로 '추가 변화 사항'이 생기는 객체들을 의미한다.

객체와 주체가 분리되어있는 옵저버 패턴과, 객체와 주체가 합쳐진 옵저버 패턴이 있다.

옵저버 패턴은 주로 이벤트 기반 시스템에 사용하며 MVC(Model-View-Controller)패턴에도 사용된다.

**자바스크립트에서의 옵저버 패턴**
자바스크립트의 옵저버 패턴은 프록시 객체를 통해 구현할 수 있다.

**프록시 객체**
프록시(proxy) 객체는 어떠한 대상의 기본적인 동작 *(속성 접근, 할당, 순회, 열거, 함수 호출 등)*을 가로챌 수 있는 객체이다.
자바스크립트에서 프록시 객체는 두 개의 매개변수를 가진다.

- target: 프록시할 대상
- handler:target 동작을 가로채고 어떠한 동작을 할 것인지 설정되어 있는 함수

**프록시 객체는 디자인 패턴 중 하나인 프록시 패턴이 녹어들어 있는 객체이다.**

#### 1.1.5 프록시 패턴과 프록시 서버

**프록시 패턴**
프록시 패턴(proxy pattern)은 대상 객체(subject)에 접근하기 전 그 접근에 대한 흐름을 가로채 대상 객체 앞단의 인터페이스 역할을 하는 디자인 패턴이다.

- 객체의 속성, 변환 등을 보완하며 보안, 데이터 검증, 캐싱, 로깅에 사용한다.
- 프록시 객체로 쓰이기도 하지만 프록시 서버로도 활용된다.

> **프록시 서버에서의 캐싱**
> 캐시 안에 정보를 담아두고, 캐시 안에 있는 정보를 요구하는 요청에 대해 다시 멀리있는 원격 서버에 요청하지 않고 캐시 안에 있는 데이터를 활용하는것을 말한다.
> 불피요하게 외부와 연결하지 않기 때문에 트래픽을 줄일 수 있다.

**프록시 서버**
프록시 서버(proxy server)는 서버와 클라이언트 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용 프로그램이다.

- nginx
  - node.js 서버 앞단의 프록시 서버로, 비동기 이벤트 기반의 구조와 다수 연결을 효과적으로 처리 가능한 웹 서버
  - nginx를 프록시 서버 앞단에 높고 node.js를 뒤에 놓음으로 익명 사용자가 직접 서버에 접근하는것을 차단하고 간접적으로 접근하게 만들어 보안을 강화할 수 있다.

> 버퍼(데이터가 저장되는 메모리 공간) 오버플로우
> 메모리 공간을 벗어나는 경우로 사용되지 않아야 할 영역에 데이터가 덮어씌워져 주소, 값을 바꾸는 공격이 발생할 수 있다.

> gzip 압축
> LZ77과 Huffman 코딩 조합인 DEFLATE 알고리즘을 기반으로 한 기술.
> 데이터 전송량을 줄일 수 있는 장점이 있지만, 압축을 해제했을 때 서버의 CPU 오버헤드도 생각해서 사용 유무를 결정해야한다.

- CloudFlare
  - 전 세계적으로 분산된 서버가 있는 CDN 서비스.
  - 시스템의 콘테츠 전달을 빠르게 할 수 있다.
  - 웹 서버 앞단에 프록시 서버로 두어 DDOS 공격이나 HTTPS 구축에 쓰인다.
  - 의심스로운 트래픽인지 파악하고 CAPTCHA 등을 기반으로 이를 일정 부분 막아준다.

_DDOS 공격 방어_
DDOS는 짧은 기간 동안 네트워크에 많은 요청을 보내 네트워크를 마비시켜 웹 사이트의 가용성을 방해하는 사이버 공격 유형이다. **CloudFlare**는 의심스러운 트래픽을 자동으로 차단해 DDOS 공격으로 부터 보호한다.

_HTTPS 구축_
서버에서 HTTPS를 구축할 때 인증서를 기반으로 구축할 수 있지만 **CloudFlare**를 사용하면 별도의 인증서 설치 없이 쉽게 구축이 가능하다.

**CORS와 프론트엔드의 프록시 서버**
CORS(Cross-Origin-Resource Sharing)는 서버가 웹 브라우저에서 리소스를 로드할 때 다른 오리진을 통해 로드하지 못하게 하는 HTTP헤더 기반 메커니즘이다.
CORS 에러를 해결하기 위해 프론트엔드에서 프록시 서버를 만들기도한다 (프록시 서버를 통해 오리진을 바꿀 수 있다).

#### 1.1.6 이터레이터 패턴

이터레이터 패턴(iterator pattern)은 이터레이터(iterator)를 사용하여 컬렉션(collection)의 요소들에 접근하는 디자인 패턴이다.

- 여러 가지 자료형의 고주와 상관없이 이터레이터라는 하나의 인터페이스로 순회가 가능하다.

> **이터레이터 프로토콜**
> 이터러블한 객체들을 순회할 때 쓰이는 규칙
>
> **이터러블한 객체**
> 반복 가능한 객체로 배열을 일반화한 객체

#### 1.1.7 노출모듈 패턴

노출모듈 패턴(revealing module patter)은 즉시 실행 함수를 통해 private, public 같은 접근 제어자를 만드는 패턴을 말한다.

- 자바스크립트는 private나 public 같은 접근 제어자가 존재하지 않고 전역 범위에서 스크립트가 실행되기 때문에 노출 모듈 패턴을 통해 private와 public 접근 제어자를 구현한다.

#### 1.1.8 MVC 패턴

MVC 패턴은 model, view, controller로 이루어진 디자인 패턴이다.
애플리케이션의 구성 요소를 세가지 역할로 구분하여 개발 프로세스에서 각각의 구성 요소에만 집중해서 개발할 수 있다.

- 장점: 재사용성과 확장석이 용이하다.
- 단점: 애플리케이션이 복잡해질 수록 모델과 뷰의 관계 또한 복잡해진다.

**모델**
모델(model)은 애플리케이션의 데이터인 데이터베이스, 상수, 변수 등을 뜻한다.

- 뷰에서 데이터를 생성, 수정하면 컨트롤러를 통해 모델을 생성, 갱신한다.

**뷰**
뷰(view)는 모델을 기반으로 사용자가 볼 수 있는 화면이다.

- inputbox, checkbox, textarea 등 사용자 인터페이스 요소.
- 모델이 가지고 잇는 정보를 따로 저장하지 않고 단순히 화면에 표시하는 정보만 가지고 있어야한다.
- 변경이 일어나면 컨트롤러에 전달해야한다.

**컨트롤러**
컨트롤러(controller)는 하나 이상의 모델과 하나 이상의 뷰를 잇는 다리역할을 하며 이벤트 등 메인 로직을 담당한다.

- 모델과 뷰의 생명주기 관리를 한다.
- 모델이나 뷰의 변경 통지를 받으면 해석하여 각각의 구성 요소에 해당 내용에 대해 알려준다.

**MVC 패턴을 이용한 대표적인 프레임 워크로 spring이 있다.**

#### 1.1.9 MVP 패턴

MVP 패턴은 MVC 패턴으로 부터 파생 되었으며 MVC 에서 Controller가 Presenter로 교체된 패턴이다.

- 뷰와 프레젠터는 일대인 관계로 MVC 패턴보다 더 강한 결합을 지닌 디자인 패턴이다.

#### 1.1.10 MVVM 패턴

MVVM 패턴은 MVC 패턴의 controller가 view model로 바뀐 패턴이다. MVVM 패턴은 MVC 패턴과 다르게 커멘드와 데이터 바인딩을 가진다.

- 뷰모델은 뷰를 더 추상화한 계층.
- 장점: 뷰와 뷰모델 사이의 양방향 데이터 바인딩을 지원하며 UI를 별도의 코드 수정 없이 재사용할 수 있다.
- 장점: 단위테스팅이 쉽다.

**MVVM 패턴을 가진 대표적인 프레임워크로 뷰(View.js)가 있다.**

- 반응형이 특징인 프런트엔드 프레임 워크
  - watch, computed 등으로 쉽게 반응형적인 값들을 구할 수 있다.

> **커맨드**
> 여러가지 요소에 대한 처리를 하나의 액션으로 처리할 수 있는 기법
>
> **데이터 바인딩**
> 화면에 보이는 데이터와 웹 브라우저의 메모리 데이터를 일치시키는 기법
> 뷰 모델을 변경하면 뷰가 변경된다.

25/07/2023 @j1y0ungyoon
