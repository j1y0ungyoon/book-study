# 1.2 프로그래밍 패러다임

프로그래머에게 프로그래밍의 관점을 갖게 해주는 역할을 하는 개발 방법론

프로그래밍 패러다임
┗ 선언형
&nbsp; &nbsp; &nbsp;┗ 함수형
┗ 명령형
&nbsp; &nbsp; &nbsp;┗ 객체 지향형
&nbsp; &nbsp; &nbsp;┗ 절차 지향형

## 1.2.1 선언형과 함수형 프로그래밍

**선언형**

- '무엇을' 풀어내는가에 집중하는 패러다임

**함수형 프로그래밍**

- 선언형 패러다임의 일종
- 작은 단위의 순수 함수들을 쌓아 로직을 구현하고 고차 함수를 통해 재사용성을 높인 프로그래밍 패러다임

### 예시

```
const list = [1,2,3,4,5]
const sum = list.reduce((pre, cur) => pre + cur, 0)
console.log(sum)

```

위의 예시에서 reduce는 배열만 받아서 누적한 결과값을 반환하는 순수함수임

<br/>

자바스크립트에서는 함수가 일급 객체이기 때문에 객체 지향 프로그래밍보다는 함수형 프로그래밍이 더 선호됨

## 1.2.3 객체지향 프로그래밍(OOP)

- 객체들의 집합으로 프로그램의 상호 작용을 표현함
- 데이터를 객체로 취급해 객체 내부에서 선언된 메소드를 활용하는 방식을 말함
- 설계에 많은 시간 소요, 처리 속도가 다른 프로그래밍 패러다임에 비해서 느림

### 예시

```
const a = [1,2,3,4,5]

class List {
   constructor(list) {
      this.list = list
      this.mx = list.reduce((max, num) => num > max ? num : max, 0)
   }
   getMax() {
      return this.mx
   }
}

const b = new List(a)
console.log(b.getMax()) // 5

```

### 객체지향 프로그래밍의 특징

1. 추상화
   복잡한 시스템으로부터 핵심적인 내용 또는 기능을 간추려내는 것

2. 캡슐화
   객체의 속성과 메소드를 하나로 묶고 일부를 외부에 감추어 은닉하는 것

3. 다형성

- 하나의 메소드가 다양한 방법으로 동작하는 것을 말함
- 예시 : 오버로딩, 오버라이딩

**오버로딩**

- 같은 이름을 가진 메소드를 여러 개 두는 것
- 메소드의 타입이나 매개변수 유형, 개수 등으로 여러 개를 둘 수 있음
- 컴파일 중에 발생하는 정적 다형성

```
// 자바 예시
class Person {
public void eat(String a) {
   system.out.printIn('I eat '+ a);
}

public void eat(String a, String b) {
   System.out.printIn('I eat '+ a + 'and" + b)
}
}

public class CalculateArea {
   public static void main(String[], args) {
      Person a = new Person();
      a.eat('apple')
      a.eat('tomato', 'peaches')
   }

}

// I eat apple
// I eat tomato and peaches

```

위의 예시를 보면 매개변수의 개수에 따라 다른 함수가 호출됨

**오버라이딩**

- 메소드 오버라이딩을 말함
- 상위 클래스로부터 상속 받은 메소드를 하위 클래스가 재정의하는 것
- 런타임 중에 발생하는 동적 다형성

4. 상속성
   상위 클래스의 특성을 하위 클래스가 이어 받아 재사용하거나 추가, 확장하는 것을 말함

### 설계원칙

객체지향 프로그래밍을 할 때는 SOLID 원칙을 지켜야함

1. 단일 책임 원칙(S)
   모든 클래스는 각각 하나의 책임만 가져야 함

2. 개방-폐쇄 원칙(O)

- 유지보수 사항이 생긴다면 코드를 쉽게 확장할 수 있도록 하고 수정할 때는 닫혀있어야 함
- 즉, 기존의 코드는 잘 변경하지 않으면서도 확장은 쉽게 할 수 있어야 함

3. 리스코프 치환 원칙(L, LSP)

- 객체의 프로그램의 정확성을 깨지 않으면서도 하위 타입의 인스턴스로 바꿀 수 있어야함
- 즉, 부모 객체에 자식 객체를 넣어도 시스템이 문제 없이 돌아가게 만드는 것

4. 인터페이스 분리 원칙(I, ISP)

- 하나의 일반적인 인터페이스보다 구체적인 여러 개의 인터페이스를 만들어야하는 원칙

5. 의존 역전 원칙(DIP)

- 자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향 받지 않게 하는 원칙
- 즉, 상위 계층은 하위 계층의 변화에 대한 구현으로부터 독립해야함

## 1.2.3 절차형 프로그래밍

- 로직이 수행되어야 할 연속적인 계산 과정으로 이루어짐
- 가독성이 좋고 구현이 빠름(그래서 계산이 많은 작업(머신 러닝 배치, 과학 관련 연산 작업 등)에 사용)
- 모듈화가 어렵고 유지 보수성이 떨어짐
